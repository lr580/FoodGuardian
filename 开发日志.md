# 程序思路

相当一部分内容在草稿本手稿里

## 全局变量/常量

部分说明如下

### 全局变量

#### stt

- 0 游戏中
- 1 基本操作的CD时间
- 2 输了
- 3 赢了
- 10 首次进入游戏
- 11主界面
- 12 

## 界面设置

### 初始化

首次进入在背景前或后进入。可选。

主要包括：输入玩家ID。

### 背景

一页文字；首次进入时进入。可以在主界面再次进入。

### 主界面

stt为11

包括主界面状态栏：

- 玩家ID(可选)
- 选择状态：
  - 所选技能(及其描述)
  - 当前关卡(及关卡名描述：如果建立)
- TIPS(操作技巧、设置技巧、环保知识随机播放)(可选)

游戏大LOGO

主按钮：(及其点入stt ID 和点入界面)

- 开始游戏 0
- 关卡设置 13
  - 关卡选择 30
    - 第一关~第十关 50~59
      - 每页5个关卡展览
      - 关卡如果已经打过，显示最好记录(可选)
        - 最好标准：耗电低；包含所选技能和游戏时间(精确到分钟或秒)
    - 上一页 30
    - 下一页 31
    - 无尽模式 32
      - 同理(但改为坚持时间)
    - 沙盒模式 (可选)
      - 可以自己创建关卡；可以将创建的关卡用其他途径上传给制作者(我)，留下联系方式
    - 返回
  - 技能选择 40
    - 六个技能 41~46
      - 标注：技能描述；是否已选；是否已解锁
    - 返回
- 游戏帮助 14
  - 游戏规则 21
    - 一页
    - 返回按钮
  - 操作指南 22
    - 一页
    - 返回按钮
  - TIPS(可选) 23 :24~28
    - 多页 
    - 上一页(首次没有)
    - 下一页(首次没有)
    - 第一页(可选)
    - 最后一页(可选)
    - 返回按钮
  - 返回按钮
- 游戏背景 15
  - 界面只有一页，显示背景+关于(同背景界面)
  - 返回按钮
- 退出

## 事件

思路：使用独立变量配合stt使用

总事件及其触发：(共10个事件)

1. 背景+玩法 首次进入游戏
2. 新敌人 首次进入第二关/第五关
3. 新技能解锁 首次通过技能解锁关
4. 无尽模式解锁 首次通关

## 读写设置

当下版本不设置初始化、玩家ID、多存档。

文件名为saves.tx

保存内容：(exec格式，AES加密，密码为lr581)

- 已通过最高关卡 mlv=int
- 状态 stt=int
  - 首次为10，否则为11
- 上次所选技能 msk=list(int, int)
- 最好通关记录 record=list(int/float, sk, st)
  - 代表损电(一般模式)/时间(无尽模式),所选技能
  - 通过时间(年int, 月int, 日int, 时int, 分int, 秒Int)或时间戳

初始化文件内容为：

> 'stt=11\nmlv=0\nmsk=[]\nrecord=[]'

其AES加密为：

> 96d2a78930e971618e896ddb31e32b914a696753bcf74b590ab9d65fe7f2f316

修改后默认初始化文件：

> 'stt=99\nmlv=0\nmsk=[]\nrecord=[]'

AES:

> 1d551beccd753cfa7f1c5c662199a14d79fd02af66893a5cd94e511a7f698660

## 关卡

除去无尽模式，共10关。

- 第一关只有白灯
- 第二关引入红灯
- 第三关引入技能：疾速
- 第四关引入技能：闪现
- 第五关引入黑灯
- 第六关引入技能：范围
- 第七关引入技能：回电
- 第八关引入技能：锁定
- 第九关引入技能：全清
- 第十关

随机刷灯保证存在不少于一种技能策略，大概率下可以通关；

固定刷灯保证存在不少于一种技能策略，绝对可以通关。

## 技能

### 疾速

持续时间20s CD35 可用3次

修改建议：持续时间25s，蓝色也挡不住，

### 闪现

CD20 可用4次

修改建议:CD10秒，可用10次

再次修改建议：CD8秒，可用12次

再次修改建议：CD6秒，可用14次

再次修改建议：CD5秒，可用16次

#### 设想1：

通过系统计算，传送至理论上能够最快减少最多能耗的位置，计算算法待定，可能需要用到DFS等。

#### 设想2：

手动闪现。

### 范围

CD15 可用4次

修改建议：加多一次

修改建议：再加一次，CD12秒

对黑灯也一样清理

### 回电

增加150电量 CD45 可用2次

### 锁定

持续20s CD30 可用3次

#### 设想1：

最优锁定，算法待定

#### 设想2：

玩家锁定

#### 设想3：

本行锁定

#### 实现：

可以增加一个light对象(并修改bulbs)，其CD为TIMELIM，即永远不会触发耗电，时间过后启动函数消灭(self.CD为TIMELIM的所有实例)

### 全清

只能用1次

修改建议：80CD，能用2次

再次修改建议：45CD，能用3次

再次修改建议：40CD，能用3次

## 音效

成功普通攻击随机播放三种音效之一 hit1, hit2, hit3

成功使用回电、疾速、闪现同一音效(arrow_hit) ski1

成功使用范围、锁定一个音效(anvil_hit) ski2

成功使用全清一个音效(关——掉——)  ski3

其他事件均无音效

## 彩蛋

彩蛋1触发条件:
耗电数为580且获胜
彩蛋2触发条件:
无尽模式坚持580秒以上
彩蛋3触发条件:
在任意小时58分58秒结束并获胜
彩蛋4触发条件:
通过非正常手段修改存档文件，使通关记录缺失

## 其他设想更新内容

1. 对所有外置数据使用AES加密解密，密钥为lr581(已实现)
2. 将黑灯改为其他颜色，如橙灯

## 编译指令

```cmd
pyinstaller combine.py -F -w -i icon.ico
```

对comine.py使用

## 已修复bug

### black

#### 014

1. 一开始时直接按回车会炸；但是其他情况不会。
2. quit没有反应(大概是线程没有关闭)
3. 时间与帧速明显不一致，帧速1s明显慢于实际1s
4. 技能栏暂未显示技能描述

### shutbulb

1. 切换背景音乐时，直接无视关闭音效而直接播放

(题外话)修改.ogg的名称会让文件管理器卡半天

### inner

1. 偶尔会出现重复刷灯或突然大量刷灯的现象，集中出现在spawncolumn, spawnlayer两个子函数中
2. 关卡选择中选择某关并开始后，结束关卡后重复选择该关会直接开始

# 数据反馈

## C

### C1

每三秒出一个白，第二个三秒两个白，循环120秒，常规玩家损电为378

### C2

对于TX0，如果完全不操作：

- 剩余时间86.8
- 损电585
- 剩余灯：
  - 白灯23

### C3

```python
spawn.append([120, 2, 5, 0])
spawn.append([118, 1, 4, 1])
spawn.append([116, 1, 3, 2])
spawn.append([114, 3, 2, 3])
spawn.append([112, 1, 1, 2])
spawn.append([110, 1, 0, 1])
spawn.append([108, 2, 1, 0])
spawn.sort(key=lambda x:x[0],reverse=True)
```

12秒后耗电约60

## S

### S1

对于如下测试关卡(记作TX0)：

```python
j=0
for i in range(120,-1,-3):
    spawn.append([i,1,-1,-1])
    if(j%2):
        spawn.append([i,1,-1,-1])
    j+=1
spawnlayer(spawn, 100)
spawncolumn(spawn, 75)
spawnlayer(spawn, 50)
spawnall(spawn, 20)
spawn.sort(key=lambda x:x[0],reverse=True)
```

无法过关，数据为：

- 剩余时间12.0
- 损电590
- 剩余灯：
  - 白灯16

### S2

对于测试关卡(TX1):

```python
j=0
for i in range(120,-1,-3):
    spawn.append([i,1,-1,-1])
    if(j%2):
        spawn.append([i,1,-1,-1])
    j+=1
spawnlayer(spawn, 100)
spawncolumn(spawn, 75)
spawnlayer(spawn, 50)
spawnall(spawn, 3)
spawn.sort(key=lambda x:x[0],reverse=True)
```

如果正常操作，可以过关：

- 剩余时间0.0
- 损电498
- 剩余灯
  - 白灯18

可以作为关卡1(气人的难度)



最新数据(左右移速慢了一倍之后)：

使用技能范围和回血，仍不能过关：

- 剩余时间2.8
- 损电583
- 剩余灯
  - 白灯24

使用技能闪现和锁定(不可鼠标设置)，不能过关(近似等效于无技能)：

- 剩余时间31.6
- 损电583
- 剩余灯
  - 白灯3

使用技能疾速(修改为次数3)和回血，可以过关：

- 剩余时间0.0
- 损电209
- 剩余灯
  - 白灯19

使用技能范围和全清，可以过关：

- 剩余时间0.0
- 损电479
- 剩余灯
  - 白灯0

### S3

对于测试关卡(TX2):

```python
j=0
for i in range(120,-1,-3):
    spawn.append([i,1,-1,-1])
    if j%5==2 or j%5==4:
        spawn.append([i,2,-1,-1])
    elif j%5==3:
        spawn.append([i,3,-1,-1])
    j+=1
spawnlayer(spawn, 90)
spawncolumn(spawn, 45)
spawncolumn(spawn, 5, ty=2)
spawn.sort(key=lambda x:x[0],reverse=True)
```

正常操作，可以过关：

- 剩余时间0.0
- 损电521
- 剩余灯
  - 白灯1
  - 红灯1



更新测试数据(左右移速减半)：

选择技能范围+全清，不能过关：

- 剩余时间16.6
- 损电583
- 剩余灯
  - 2白灯
  - 1红灯
  - 1黑灯

选择技能锁定+回血，不能过关：

- 剩余时间2.2
- 损电581
- 剩余灯
  - 白灯3
  - 红灯4
  - 黑灯1

同样再次尝试：

- 剩余时间0.0
- 损电453
- 剩余灯
  - 白灯3
  - 红灯2

- 剩余时间4.0
- 损电581
- 剩余灯
  - 白灯2
  - 红灯2
  - 黑灯1

技能增强后：

使用范围+闪现，闯关失败：

- 剩余时间3.2
- 损电581
- 剩余灯
  - 白灯1
  - 红灯1
  - 黑灯1

使用疾速+锁定，闯关失败：

- 剩余时间11.2
- 损电581
- 剩余灯
  - 白灯2

再次加强后，全清+回电，闯关成功：

- 剩余时间0.0
- 损电549
- 剩余灯
  - 红灯1

疾速+锁定，闯关成功：

- 剩余时间0.0
- 损电575
- 剩余灯
  - 白灯1
  - 红灯3

闪现+范围，闯关成功：

- 剩余时间0.0
- 损电486
- 剩余灯
  - 白灯1
  - 红灯1

闪现+范围，闯关失败：(数据完全未改)

- 剩余时间17.4
- 损电581
- 剩余灯
  - 白灯2
  - 红灯1

闪现+范围，闯关成功：(数据完全未改)

- 剩余时间0.0
- 损电559
- 剩余灯
  - 白灯1
  - 红灯1

闪现+回血，闯关成功：(数据完全未改)

- 剩余时间0.0
- 损电510
- 剩余灯
  - 白灯2
  - 红灯1
  - 黑灯1

闪现+锁定，闯关失败：(数据完全未改)

- 剩余时间3.8
- 损电581
- 剩余灯
  - 白灯1
  - 红灯3
  - 黑灯1

范围+回血，闯关成功：(数据完全未改)

- 剩余时间0.0
- 损电569
- 剩余灯
  - 白灯1
  - 红灯1
  - 黑灯1

范围+疾速，不能过关：(数据完全未改)

- 剩余时间3.4
- 损电581
- 剩余灯
  - 红灯4
  - 黑灯1

## LV

### LV1

#### VER1

```python
spawnlayer(spawn, 90)
spawncolumn(spawn, 50)
spawnlayer(spawn, 10)
j, cdf = 0, 120
while cdf>3:#cdf>0时有离奇bug导致最后两个灯summon函数出错
    spawn.append([cdf,1,-1,-1])
    if j%2:
        cdf-=4
    else:
        spawn.append([cdf,1,-1,-1])
        cdf-=5
    j+=1
spawn.sort(key=lambda x:x[0],reverse=True)
```

测试数据：

3次正常操作，平均损电数为260

### LV2

#### VER1

```python
j, cdf = 0, 120
while cdf>90:
    spawn.append([cdf,1,-1,-1])
    if j%2:
        cdf-=4
    else:
        spawn.append([cdf,1,-1,-1])
        cdf-=5
    j+=1
spawncolumn(spawn, 70)
spawncolumn(spawn, 12, 2)
while cdf>3:
    if j%4==1 or j%4==0:
        spawn.append([cdf,1,-1,-1])
    elif j%4==2:
        spawn.append([cdf,1,-1,-1])
        spawn.append([cdf,1,-1,-1])
    elif j%4==3:
        spawn.append([cdf,2,-1,-1])
    if randint(0,4)==0:
        spawn.append([cdf,2,-1,-1])
    cdf-=4.5
    j+=1
spawn.sort(key=lambda x:x[0],reverse=True)
```

测试数据：

3次正常操作，平均损电数为378

### LV3

#### VER1

```python
j, cdf = 0, 118
rlay = randint(0,LAYER-1)
for k in range(3):
    spawn.append([cdf+k, 2, -1, rlay])
while cdf>1:
    if j%4==0 or j%4==1:
        spawn.append([cdf,1,-1,-1])
    elif j%4==2:
        spawn.append([cdf,1,-1,-1])
    elif j%4==3:
        spawn.append([cdf,2,-1,-1])
    if randint(0,4)==0:
        spawn.append([cdf,2,-1,-1])
    cdf-=4.1
    j+=1
spawncolumn(spawn, 100, 0)
spawnlayer(spawn, 50, 0)
spawnlayer(spawn, 50, 3)
spawnlayer(spawn, 6, ty=2)
spawn.sort(key=lambda x:x[0],reverse=True)
```

测试数据：

不使用任何技能：

1. 成功 耗电576
2. 失败 耗电582 剩余3.8s 7红灯
3. 失败 耗电582 剩余3.7s 5红灯
4. 失败 耗电581 剩余25.8s 1红灯 3白灯
5. 失败 耗电581 剩余13.3s 1红灯 2白灯

使用疾速：

1. 成功 耗电486 剩余1白灯
2. 成功 耗电354
3. 失败 耗电581 剩余0.3s   2白灯 2红灯
4. 成功 耗电511

### LV4

#### VER1

```python
j, cdf = 0, 120
while cdf>1:
    if j%4==0 or j%4==1:
        spawn.append([cdf,1,-1,-1])
    elif j%4==2:
        spawn.append([cdf,1,-1,-1])
    elif j%4==3:
        spawn.append([cdf,2,-1,-1])
    if randint(0,7)==0:
        spawn.append([cdf,2,-1,-1])
    cdf-=4
    j+=1
spawncolumn(spawn, 100, 0)
spawncolumn(spawn, 40, ty=2)
spawncolumn(spawn, 70, 0)
spawnrange(spawn, 110)
spawnrange(spawn, 25)
spawn.sort(key=lambda x:x[0],reverse=True)
```

使用疾速+闪现：

1. 成功 耗电485 剩余5次传送
2. 成功 耗电363 剩余3次传送
3. 失败 耗电581 剩余11.4s
4. 成功 耗电516

### LV5

#### VER1

```python
j, cdf = 0, 116
rlay = randint(0,LAYER-1)
for i in range(5):
    spawn.append([cdf+i, 2, -1, rlay])
spawncolumn(spawn, 100, 1, 2)
while cdf>90:
    spawn.append([cdf,1,-1,-1])
    spawn.append([cdf,2,-1,-1])
    cdf-=4.6  
while cdf>2:
    if j%4==0:
        spawn.append([cdf,3,-1,-1])
    elif j%4==1 or j%4==3:
        spawn.append([cdf,1,-1,-1])
    elif j%4==2:
        spawn.append([cdf,2,-1,-1])
    if randint(0,7)==0:
        spawn.append([cdf,3,-1,-1])
    j+=1
    cdf-=4.1
spawnlayer(spawn, 45, ty=3)
spawnrange(spawn, 15)
spawn.sort(key=lambda x:x[0],reverse=True)
```

使用疾速+闪现：

1. 通过 耗电477 剩余闪现7次
2. 通过 耗电527 剩余闪现8次
3. 通过 耗电478 剩余闪现9次
4. 通过 耗电564 剩余闪现8次

### LV6

#### VER1

```python
j, cdf = 0, 120
while cdf>1.5:
    if j%4==0:
        spawn.append([cdf,3,-1,-1])
    elif j%4==1 or j%4==3:
        spawn.append([cdf,1,-1,-1])
    elif j%4==2:
        spawn.append([cdf,2,-1,-1])
    rd = randint(0,9)
    if rd==0:
        spawn.append([cdf,3,-1,-1])
    elif rd==1:
        spawn.append([cdf,2,-1,-1])
    elif rd==2 or rd==3:
        spawn.append([cdf,1,-1,-1])
    j+=1
    cdf-=4.1
spawnrange(spawn, 110, ty=3)
spawnrange(spawn, 85)
spawnrange(spawn, 50, ty=2)
spawnlayer(spawn, 30)
spawnrange(spawn, 10)
spawn.sort(key=lambda x:x[0],reverse=True)
```

使用闪现+范围：

1. 通过 耗电427 剩余范围2 闪现8
2. 通过 耗电378 剩余范围2 闪现7 白灯1

使用闪现+疾速：

1. 失败 耗电583 剩余疾速1 闪现9 白灯4 红灯1

使用疾速+范围：

1. 通过 耗电368 剩余范围2
2. 通过 耗电471 剩余范围1
3. 通过 耗电419 剩余范围2

### LV7

#### VER1

```python
j, cdf = 0, 120
spawnlayer(spawn, 120)
spawnrange(spawn, 100)
spawncolumn(spawn, 80, ty=3)
spawncolumn(spawn, 60)
spawncolumn(spawn, 40, ty=2)
spawncolumn(spawn, 20, ty=3)
spawn.append([4, 2, -1, -1])
while cdf>6:
    if j%4==0:
        spawn.append([cdf,3,-1,-1])
    elif j%4==1 or j%4==3:
        spawn.append([cdf,1,-1,-1])
    elif j%4==2:
        spawn.append([cdf,2,-1,-1])
    if randint(0,10)==1:
        spawnquick(spawn, cdf)
    j+=1
    cdf-=4.1
spawn.sort(key=lambda x:x[0],reverse=True)
```

使用疾速+全清：

1. 通过 耗电507 剩余全清1
2. 通过 耗电514 

使用闪现+全清：

1. 失败 耗电582 剩余时间30.0 全清1 闪现8 白灯3 红灯2

使用范围+全清：

1. 通过 耗电439
2. 通过 耗电451 剩余范围1

### LV8

#### VER1

```python
j, cdf = 0, 120
spawnrquick(spawn, 120, 7, r=1)
spawncolumn(spawn, 100, ty=2)
spawnrange(spawn, 80, ty=3)
spawnlayer(spawn, 60, randint(0,1))
spawnlayer(spawn, 60, randint(2,3))
spawncolumn(spawn, 40, ty=3)
spawnrquick(spawn, 20, 11, r=randint(0,LAYER-1))
while cdf>6:
    if j%4==0:
        spawn.append([cdf,3,-1,-1])
    elif j%4==1 or j%4==3:
        spawn.append([cdf,1,-1,-1])
    elif j%4==2:
        spawn.append([cdf,2,-1,-1])
    j+=1
    cdf-=3
spawn.sort(key=lambda x:x[0],reverse=True)
```

使用范围+回血：

1. 通过 耗电511

使用范围+全清：

1. 通过 耗电507 剩余 范围2

使用传送+回血

1. 失败 还剩51.5s 12白灯 1红灯 1蓝灯

使用疾速+回血：

1. 通过 耗电416

### LV9

#### VER1

```python
j=0
for i in range(120,-1,-3):
    spawn.append([i,1,-1,-1])
    if j%5==2 or j%5==4:
        spawn.append([i,2,-1,-1])
    elif j%5==3:
        spawn.append([i,3,-1,-1])
    j+=1
spawnlayer(spawn, 90)
spawncolumn(spawn, 45)
spawncolumn(spawn, 2, ty=2)
spawn.sort(key=lambda x:x[0],reverse=True)
```

使用范围+锁定：

1. 通过 耗电576 剩余红灯1 蓝灯1
2. 失败 耗电581 剩余5.6s 红灯2 蓝灯1 白灯1

#### VER2

```python
j=0
for i in range(120,-1,-3):
    spawn.append([i,1,-1,-1])
    if j%5==2 or j%5==4:
        spawn.append([i,2,-1,-1])
    elif j%5==3:
        spawn.append([i,3,-1,-1])
    j+=1
spawnlayer(spawn, 90)
spawncolumn(spawn, 45)
spawn.sort(key=lambda x:x[0],reverse=True)
```

1. 范围+锁定 耗电547 白灯1
2. 全清+锁定 剩余2.1s 耗电581 白灯1 红灯1
3. 疾速+锁定 耗电484 白灯1 红灯1
4. 闪现+回血 耗电439 白灯1 红灯1 闪现3

#### VER3

```python
j=0
for i in range(120,-1,-3):
    spawn.append([i,1,-1,-1])
    if j%5==2 or j%5==4:
        spawn.append([i,2,-1,-1])
    elif j%5==3:
        spawn.append([i,3,-1,-1])
    j+=1
spawnlayer(spawn, 90)
spawncolumn(spawn, 45)
spawncolumn(spawn, 3.5, ty=2)
spawn.sort(key=lambda x:x[0],reverse=True)
```

1. 闪现+回血 耗血269 白灯1 红灯2 蓝灯1 闪现2
2. 疾速+回血 耗血340 白灯2 红灯3
3. 疾速+回血 耗血447 白灯2 红灯4

### LV10

#### VER1

```python
j, ct= 0, 112
spawnrange(spawn, 120, 4, 1, 3)
while ct>18:
    if j%5 == 2 or j%5 == 4:
        spawn.append([ct, 2, -1, -1])
    elif j%5 == 3:
        spawn.append([ct, 3, -1, -1])
    else:
        spawn.append([ct, 1, -1, -1])
    ct -= 2.2
    j += 1
spawnrquick(spawn, 15, 15)
spawn.sort(key=lambda x:x[0],reverse=True)
```

1.闪现+回血 耗血385

#### VER2

```python
j, ct= 0, 112
spawnrange(spawn, 120, 4, 1, 3)
spawncolumn(spawn, 90, 2, 3)
spawnlayer(spawn, 50, 2)
while ct>18:
    if j%5 == 2 or j%5 == 4:
        spawn.append([ct, 2, -1, -1])
    elif j%5 == 3:
        spawn.append([ct, 3, -1, -1])
    else:
        spawn.append([ct, 1, -1, -1])
    ct -= 2.2
    j += 1
spawnrquick(spawn, 15, 15)
spawn.sort(key=lambda x:x[0],reverse=True)
```

1. 闪现+回血 两次死在最后两秒

#### VER3

```python
j, ct= 0, 112
spawnrange(spawn, 120, 4, 1, 3)
spawncolumn(spawn, 90, 2, 3)
spawnlayer(spawn, 50, 2)
while ct>15:
    if j%5 == 2 or j%5 == 4:
        spawn.append([ct, 2, -1, -1])
    elif j%5 == 3:
        spawn.append([ct, 3, -1, -1])
    else:
        spawn.append([ct, 1, -1, -1])
    ct -= 2.2
    j += 1
spawnrquick(spawn, 12, 12)
spawn.sort(key=lambda x:x[0],reverse=True)
```

1. 闪现+回血 通过530
2. 疾速+回血 通过415

#### VER4

```python
j, ct= 0, 112
spawnrange(spawn, 120, 4, 1, 3)
spawncolumn(spawn, 90, 2, 3)
spawnlayer(spawn, 50, 2)
while ct>18:
    if j%5 == 2 or j%5 == 4:
        spawn.append([ct, 2, -1, -1])
    elif j%5 == 3:
        spawn.append([ct, 3, -1, -1])
    else:
        spawn.append([ct, 1, -1, -1])
    ct -= 2
    j += 1
spawnrquick(spawn, 15, 15)
spawn.sort(key=lambda x:x[0],reverse=True)
```

1. 闪现+回血 通过442
2. 闪现+范围 不通过582(剩余时间0.0) 白1 红1 蓝2
3. 闪现+范围 通过486 白1 红2 蓝1
4. 疾速+回血 通过241

### INF

#### VER1

```python
def infrate(t):
    return 5-log(t/125+1,2) if t<=1200 else 1.6
def infgen():
    global infj, infp
    print('%f %d'%(infrate(stlf),stlf))
    spawn.append([stlf+infrate(stlf), hgci([1,2,3], [int(5+infrate(stlf)), 2, 3]), -1, -1])
    infj+=1
    if infj>=3 and randint(0,3)==1:
        infj = 0
        spawn.append([stlf+infrate(stlf), hgci([1,2,3], [5, 2, 3]), -1, -1])
    if 25+2*infrate(stlf)<=infp:
        infp = 0
        rp = hgci(list(range(5)), [5,6,3,6,4])
        if rp==0:
            spawnlayer(spawn, stlf, ty=hgci([1,2,3], [13, 2, 5]))
        elif rp==1:
            spawncolumn(spawn, stlf, ty=hgci([1,2,3], [13, 2, 5]))
        elif rp==2:
            spawnrange(spawn, stlf)
        elif rp==3:
            spawnquick(spawn, stlf)
        elif rp==4:
            spawnrquick(spawn, stlf)
    spawn.sort(key=lambda x:x[0])
spawn.append([0.1, 1, -1, -1])
```

1. 闪现+范围 515s
2. 疾速+全清 470s
3. 疾速+范围 620s
4. 疾速+回血 1043.7s
5. 范围+锁定 512s
6. 疾速+范围(fxx) 437.4s

## IN

### VER1

> 内容同LV

内测测试员：fxx

测试数据：

- 第一关 495
- 第二关 444
- 第三关 525 疾速 3tries
- 第四关 418 疾速、传送 (1/2tries)
- 第五关 480 疾速、传送 (1/2tries)
- 第六关 533 疾速、意念 (1/2tries)
- 第七关 496 疾速、怒吼
- 第八(?)关 521 疾速、意念(?) 实际上因BUG未通关
- 第九关 521 疾速、意念(?) 
- 第十关 因BUG未通关

# 转型思路

## 文案

### 原文案

```python
TITLE = '关掉电灯 Shut the Lights Up'
CNNUM='零一二三四五六七八九十'
SKN = ['疾速', '传送', '意念', '怒吼', '发电', '锁定']
SKDSB = ['关掉姐爆发潜能，在一段时间内移动和关灯速度大幅增加。\n在接下来的20秒内，所有移动和关灯只需要0.1秒即可。',
         '关掉姐作为栋梁之材，她习有一门绝技，可以在楼内瞬间传送至某一位置。\n按下按键释放技能后，用鼠标点击要传送到的位置即可发动技能。',
         '关掉姐强烈的节能意愿使得关掉姐及其周围八格所有亮着的灯都立刻熄灭。',
         '关掉姐一声怒吼，声波转化为电能，使电路过载，瞬间关掉所有的灯。',
         '关掉姐在B站的视频获得大量充电，这些电可以神奇地弥补浪费的电能。\n每次发动技能恢复150点被浪费的电能，恢复后的可浪费电能不大于580。\n该技能无尽模式无法使用！',
         '关掉姐作为楼房管理员，可以切断某一层楼的电闸，让该层楼断电一段时间。\n按下按键释放技能后，用鼠标点击要锁定的楼层即可发动技能。锁定瞬间会关掉该楼层所有的灯，并且锁定的楼层在20秒内不会亮起灯。']
TXBG = '你知道吗？每个出门后未随手关掉的灯都会默默地消耗电能，一盏25瓦的灯40小时会浪费一度电。假设14亿人各有一盏这样的灯，如果每盏灯每天开多半小时，浪费的总电能相当于三峡水电站一年的发电量，这浪费多么触目惊心！\n对此，关掉姐忿忿不平，她打算做一名志愿者，关掉所有人们离开时忘记关的电灯。\n(按下左下角文字按钮以继续)'
TXRUL = '每个房间的灯都可能亮起，亮起的灯会损耗电能。你的任务是控制关掉姐，关掉那些打开的灯，在规定时间内控制损耗电能不大于最大可损耗电能。\n如果是无尽模式，则你的任务是尽可能坚持足够久，尽量晚使损耗电能达到最大可损耗电能。'
TXRO = '使用WSAD控制关掉姐进行移动。每次左右移动后关掉姐需要休息0.2秒，无法活动；每次上下移动需要0.5秒。只能在楼梯口上下移动。每次关掉一盏白灯或红灯需要0.2秒，关掉蓝灯需要1秒。\n通过第二关后，将解锁技能，使用按键E或R释放技能。最多可以选择两个技能。技能详情在技能选择处查看。'
EGG = ['彩蛋1:[成就]千钧一发:你的耗电数恰好为最大损耗数！',
        '彩蛋2:[成就]节能宗师:恭喜你在无尽模式坚持了580秒以上！算下来每秒只损耗1单位电量以下呢！你一定选了技能%s吧！'%SKN[4],
        '彩蛋3:58这个数字有什么特别的含义么=w=',
        '彩蛋4th哟，斯巴拉西斯巴拉西~ -lr580卿']
STFIN = ['恭喜过关，下一关会出现新的灯：红灯，其耗电功率为白灯的2.5倍，请注意！',
         '恭喜过关，解锁技能：疾速，可前往查看！',
         '恭喜过关，解锁技能：传送，可前往查看！',
         '恭喜过关，下一关会出现新的灯：蓝灯，这种灯很难熄灭，需要消耗1秒的时间，请注意！',
         '恭喜过关，解锁技能：意念，可前往查看！',
         '恭喜过关，解锁技能：怒吼，可前往查看！',
         '恭喜过关，解锁技能：发电，可前往查看！',
         '恭喜过关，解锁技能：锁定，可前往查看！',
         '恭喜过关，下一关是最后一关常规关卡，加油！',
         '恭喜通关，已解锁无尽模式，可前往挑战！(该模式会自动回电,技能无限使用,但发电不可用)']
STBUT = ['下一关','选择技能','选择技能','下一关','选择技能',
         '选择技能','选择技能','选择技能','下一关','前往挑战']
TIPS = ['操作技巧：在需要左右移动比较短距离的时候，连按按键比按住不放更容易控制距离，以防止走过头了。',
        '游戏技巧：没有灯亮时，站在二层或三层楼梯口能够以最快速度应变新亮起的灯。',
        '游戏技巧：不要吝啬使用技能，正常情况下技能的次数都是足够使用的，尤其是传送技能。',
        '游戏技巧：如果某些关卡很难通过，尝试更换技能搭配，也许能轻而易举地过关。',
        '环保知识：5瓦的节能灯光照可视约为25瓦白炽灯；9瓦节能灯约为60瓦白炽灯。因此，使用节能灯可以在同样光强下，节省更多的电能！']
```

### 新文案

```python
TITLE = '餐馆守卫者 Food Guardian'
CNNUM='零一二三四五六七八九十'
SKN = ['疾速', '传送', '意念', '广播', '保鲜', '宣传']
SKDSB = ['你可以爆发潜能，在一段时间内移动和收拾剩菜速度大幅增加。\n在接下来的20秒内，所有移动和收拾只需要0.1秒即可。',
         '你作为栋梁之材，习有混元形意太极，可以在楼内瞬间传送至某一位置。\n按下按键释放技能后，用鼠标点击要传送到的位置即可发动技能。',
         '你强烈的保卫粮食意愿通过量子波动，使得你所在格及其周围八格所有剩菜都被自动收拾。',
         '你播放餐馆广播，以非正式学时和评优为奖励，呼吁所有在场顾客参与志愿收拾，一瞬间将场上所有剩菜收拾干净。',
         '你对剩菜使用保鲜剂耗子尾汁，使得品质大幅增加。\n每次发动技能恢复150点被损耗的品质，恢复后的可损耗品质不大于580。\n该技能无尽模式无法使用！',
         '你在某一层楼拉起横幅，呼吁顾客珍惜粮食。在这期间该层的顾客不会留下剩菜，并且主动收拾已有剩菜。\n按下按键释放技能后，用鼠标点击要宣传的楼层即可发动技能。宣传瞬间会自动收拾该层已有剩菜，并且宣传的楼层在20秒内不会有新的剩菜。']
TXBG = '据联合国报道，全球超过8.2亿人仍在挨饿！有关专家估算，我国每年在餐桌上浪费的食物约合2000亿元，相当于2亿多人一年的口粮。这鲜明的对比着实触目惊心！\n对此，作为南海校区某餐馆打工人的你想要用自己的行动减少餐馆的剩饭浪费。已知一种新技术可以加工剩饭菜，而食物越新鲜，效果越好。因此你想要以最快速度收拾顾客的剩菜。\n(按下左下角文字按钮以继续)'
TXRUL = '每个房间的餐桌都可能产生剩菜，剩菜放得越久，新鲜度越低，从而影响加工品质。你的任务是让总品质损耗尽可能降低。\n如果是通关后的无尽模式，则你的任务是尽可能坚持足够久，尽量晚使损耗品质达到最大可损耗品质。'
TXRO = '使用WSAD进行移动。每次左右移动后你需要休息0.2秒，无法活动；每次上下移动需要0.5秒。只能在楼梯口上下移动。每次收拾普通餐或大餐需要0.2秒，收拾顽固餐需要1秒。\n通过第二关后，将解锁技能，使用按键E或R释放技能。最多可以选择两个技能。技能详情在技能选择处查看。'
EGG = ['彩蛋1:[成就]千钧一发:你的损耗品质值恰好为最大可损耗值！',
        '彩蛋2:[成就]粮食守卫:恭喜你在无尽模式坚持了580秒以上！算下来每秒只损耗1单位品质以下呢！你一定选了技能%s吧！'%SKN[4],
        '彩蛋3:58这个数字有什么特别的含义么=w=',
        '彩蛋4th哟，斯巴拉西斯巴拉西~ -lr580卿']
STFIN = ['恭喜过关，下一关会出现新的剩菜：大餐，其损耗品质功率为普通餐的2.5倍，请注意！',
         '恭喜过关，解锁技能：%s，可前往查看！'%SKN[0],
         '恭喜过关，解锁技能：%s，可前往查看！'%SKN[1],
         '恭喜过关，下一关会出现新的剩菜：顽固餐，这种剩菜很难处理，需要消耗1秒的时间，请注意！',
         '恭喜过关，解锁技能：%s，可前往查看！'%SKN[2],
         '恭喜过关，解锁技能：%s，可前往查看！'%SKN[3],
         '恭喜过关，解锁技能：%s，可前往查看！'%SKN[4],
         '恭喜过关，解锁技能：%s，可前往查看！'%SKN[5],
         '恭喜过关，下一关是最后一关常规关卡，加油！',
         '恭喜通关，已解锁无尽模式，可前往挑战！(该模式会自动恢复品质,技能无限使用,但%s不可用)'%SKN[4]]
STBUT = ['下一关','选择技能','选择技能','下一关','选择技能',
         '选择技能','选择技能','选择技能','下一关','前往挑战']
TIPS = ['操作技巧：在需要左右移动比较短距离的时候，连按按键比按住不放更容易控制距离，以防止走过头了。',
        '游戏技巧：没有剩菜时，站在二层或三层楼梯口能够以最快速度应变新产生的剩菜。',
        '游戏技巧：不要吝啬使用技能，正常情况下技能的次数都是足够使用的，尤其是传送技能。',
        '游戏技巧：如果某些关卡很难通过，尝试更换技能搭配，也许能轻而易举地过关。',
        '粮食知识：剩饭剩菜可以转化为肥料、饲料，使用一些生物学新技术可以让转化率高达80%！']
```

## 新设定

操作：

灯：

- 熄灯→普通餐桌(人+(正常饭菜))
- 白灯→剩菜桌
- 红灯→大剩菜桌
- 蓝灯→顽固剩菜桌

# 更新日志

## 20/11/05

1. 实现了基本的算法逻辑和数据结构部分，包括玩家的移动、攻击和六种技能，三种敌人的生成、攻击、死亡，游戏的初始化、开始、胜负判定。
2. 实现了黑白框下的游戏界面
3. 构建了窗口化部分的基础框架

代码量进度约450行

## 20/11/06

1. 在窗口化下继承了黑白框的全部功能并实现了剩余两个技能的自主选择

代码量进度约150行

## 20/11/07

1. 完成了基本的游戏选项操作(游戏设置)
2. 完成了背景音乐和音频的功能，确定了背景音乐
3. 对六种技能和其他游戏变量确定了最终数据，增强了技能强度
4. 完成了第一关的制作

代码量进度约400行

## 20/11/08

1. 完成了2~10关的制作
2. 修复了若干bug

代码量进度约480行

## 20/11/09

1. 完成无尽模式制作
2. 完成动态移动制作
3. 完成了首次通关提示
4. 修复了若干bug

代码量约320行

## 20/11/10

1. 使用了最终的音频大部分图片，修改了文字配色
2. 完成了所有游戏内文案
3. 完善了首次进入界面
4. 进行了第一次内测

代码量约140行

## 20/11/11

1. 完成了音频和图片
2. 修改了若干按钮、提示，使游戏更方便人性化
3. 对调了第八第九关
4. 实现了编译

代码量约150行

## 20/10/19

1. 修改了无尽模式的持续时间显示、技能显示和一些其他显示

## 20/10/23

1. 修复了一个重大bug

# 游戏玩法